# -*- coding: utf-8 -*-
"""data_analisys.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qwdab1voG6VhNG8uQAHpcoerIXdcFLss

# **Análise Exploratória de Dados (EDA)**

## Importando bibliotecas
"""

# Licença: BSD 3 clause

# Importando as bibliotecas

import numpy as np
import pandas as pd

from sklearn import datasets

import random # random library
pallete = ['Accent_r', 'Blues', 'BrBG', 'BrBG_r', 'BuPu']

"""## 1. Coleta dos dados"""

# Visualizando o dataset
diabetes_X, diabetes_y = datasets.load_diabetes(return_X_y=True, as_frame=True)

diabetes_X.columns

"""### 1.1 Descrição do conjunto de dados

* $N = 442$
* Atributos: 10
    * `age` idade
    * `sex` gênero
    * `bmi` Índice de Massa Corpórea (IMC) - *Body Mass Index* (BMI)
    * `bp` pressão arterial média *blood pressure* (bp)
    * `s1` colesterol total
    * `s2` colesterol LDL
    * `s3` colesterol HDL
    * `s4` colesterol VLDL
    * `s5` triglicerides
    * `s6` glicose
* **Variável dependente**: medida quantitativa de progressão da diabetes

### 1.2 Organização do conjunto de dados
"""

diabetes_X.columns

### --> Criando novos nomes para as colunas
columns = ["Idade","Sexo","IMC","Pressão_Arterial","Colesterol_total","Colesterol_LDL","Colesterol_HDL","Colesterol_VLDL","Triglicerides","Glicose"]

### --> Atribui os novos nomes de colunas ao conjunto de dados
diabetes_X.columns = columns

## Agora vamos analisar os valores do nosso conjunto de dados:

diabetes_X

"""## 2. Pré-processamento

### 2.1 Tratar valores faltantes (*dados missing*)
"""

diabetes_X.info() ## info é específico do pandas

###### CRIANDO (FAKE) DADOS FALTANTES PARA EXEMPLIFICAR ######

# Introduzir dados faltantes nas colunas 'age' e 'bmi'
diabetes_X.loc[:2, ['Idade', 'IMC']] = None

# Mostrar os primeiros registros dos dados com valores faltantes
print(diabetes_X.head()) # '()' é uma função e recebe parâmetros

# Exemplo de heads() com parâmetros
print(diabetes_X.head(10))

diabetes_X.info()

# (1) Verificar se existe algum valor NaN em alguma tabela específica:

diabetes_X['Idade'].isnull().values.any()

# (2) Contar quantos valores NaN existem em uma tabela específica:

diabetes_X['Idade'].isnull().sum()

# (3) Verificar se existe algum valor NaN no conjunto de dados inteiro:
diabetes_X.isnull().values.any()

# (4) Contar quantos valores NaN existem por coluna:
diabetes_X.isnull().sum()

# (5) Contar quantos valores NaN existem no conjunto de dados inteiro:

diabetes_X.isnull().sum().sum()

diabetes_X.fillna('TESTE', inplace = False)

diabetes_X.drop(columns = ['Idade'], inplace = False)

diabetes_X.dropna(inplace = False, axis = 1)

diabetes_X.dropna(inplace = False, axis = 0)

###### RETORNANDO AO CONJUNTO DE DADOS ORIGINAL ######

diabetes_X, diabetes_y = datasets.load_diabetes(return_X_y=True, as_frame=True)
columns = ["Idade","Sexo","IMC","Pressão_Arterial","Colesterol_total","Colesterol_LDL","Colesterol_HDL","Colesterol_VLDL","Triglicerides","Glicose"]
diabetes_X.columns = columns
diabetes_X

"""### 2.2 Tratar dados categóricos

"""

def modificar_sexo(sexo):
    if sexo > 0:
      return "Masculino"
    else:
      return "Feminino"

# Aplicar a função à coluna 'idade' usando apply
diabetes_X["Sexo"] =diabetes_X["Sexo"].apply(modificar_sexo)

diabetes_X["Sexo"]

diabetes_X

from sklearn.preprocessing import LabelEncoder #Custa mais computacionalmente

# Inicializar o LabelEncoder
label_encoder = LabelEncoder()

# Ajustar e transformar os dados no DataFrame
diabetes_X["Sexo"] = label_encoder.fit_transform(diabetes_X["Sexo"])

# Visualizar o DataFrame resultante
diabetes_X

from sklearn.preprocessing import OneHotEncoder #Custa menos computacionalmente

# Inicializar e ajustar o codificador one-hot
encoder = OneHotEncoder(sparse_output=False)
encoded = encoder.fit_transform(diabetes_X["Sexo"].values.reshape(-1, 1))

# Criar um DataFrame com as novas colunas
diabetes_X_encoded = pd.DataFrame(encoded, columns=encoder.get_feature_names_out(['Sexo']))

print(diabetes_X_encoded)

# Escolher quais colunas manter
colunas_antes = ['Idade', 'Sexo']
colunas_depois = ["IMC","Pressão_Arterial","Colesterol_total","Colesterol_LDL","Colesterol_HDL","Colesterol_VLDL","Triglicerides","Glicose"]

# Unir os DataFrames ao longo do eixo das colunas
diabetes_X_temp = diabetes_X[colunas_antes].join(diabetes_X_encoded)
diabetes_X = diabetes_X_temp.join(diabetes_X[colunas_depois])

diabetes_X

###### RETORNANDO AO CONJUNTO DE DADOS ORIGINAL  ######

diabetes_X, diabetes_y = datasets.load_diabetes(return_X_y=True, as_frame=True)
columns = ["Idade","Sexo","IMC","Pressão_arterial","Colesterol_total","Colesterol_LDL","Colesterol_HDL","Colesterol_VLDL","Triglicerides","Glicose"]
diabetes_X.columns = columns
diabetes_X

"""## 3. Análise Exploratória de Dados

### 3.1 Descrição estatística
"""

# Importar bibliotecas

import matplotlib.pyplot as plt
import seaborn as sns

diabetes_X.describe()

"""![image.png](data:image/png;base64,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)"""

plt.figure(figsize=(10, 6))
plt.boxplot(diabetes_X, labels=diabetes_X.columns)
plt.title('Box plot of Diabetes Dataset Features')
plt.xlabel('Features')
plt.ylabel('Values')
plt.show()

plt.figure(figsize=(6, 4))
plt.boxplot(diabetes_X.iloc[:, 0])
plt.title('Box plot Variável Idade')
plt.xlabel('Idade')
plt.ylabel('Valores')
plt.show()

corr = diabetes_X.corr()
corr

plt.subplots(figsize=(8,8))
sns.heatmap(corr,cmap= 'RdYlGn',annot=True)
plt.show()

corr_var = diabetes_X.corr(method ='pearson')

plt.subplots(figsize=(8,8))
sns.heatmap(corr_var,annot=True)
plt.show()

sns.pairplot(diabetes_X,hue="Sexo", palette=random.choice(pallete))

g = sns.pairplot(diabetes_X, hue = "Idade", height = 3, palette=random.choice(pallete))
g.map_diag(sns.histplot)
g.map_offdiag(sns.scatterplot)
g.add_legend()

# # Criar DataFrame pandas com os dados e rótulos
# diabetes = pd.DataFrame(data=np.c_[diabetes_X, diabetes_y])

# Análise de dispersão entre variáveis de colesterol, glicose e triglicerides
colesterol_glicose_triglicerides = ["Colesterol_total","Colesterol_LDL","Colesterol_HDL","Colesterol_VLDL","Triglicerides","Glicose"]

for i, feature1 in enumerate(colesterol_glicose_triglicerides):
    for j, feature2 in enumerate(colesterol_glicose_triglicerides):
        if i != j:
            plt.figure(figsize=(5, 3))

            # Gráfico de dispersão
            sns.scatterplot(data=diabetes_X, x=feature1, y=feature2)
            plt.title(f'Dispersão entre {feature1} e {feature2}')
            plt.xlabel(feature1)
            plt.ylabel(feature2)
            plt.show()

# Visualizar a distribuição de todas as variáveis preditoras
plt.figure(figsize=(15, 10))
for i, feature in enumerate(diabetes_X.columns):  # Não incluir a última coluna (target)
    plt.subplot(3, 4, i + 1)
    sns.histplot(data=diabetes_X, x=feature, bins=30, kde=True)
    plt.title(f'Distribuição de {feature}')
    plt.xlabel(feature)
    plt.ylabel('Contagem')
plt.tight_layout()
plt.show()

# Visualizar gráficos de dispersão entre pares de variáveis
sns.pairplot(diabetes_X)
plt.suptitle("Gráficos de Dispersão entre Pares de Variáveis", y=1.02)
plt.show()

# Visualizar boxplots para cada variável preditora
plt.figure(figsize=(15, 10))
for i, feature in enumerate(diabetes_X.columns):  # Não incluir a última coluna (target)
    plt.subplot(3, 4, i + 1)
    sns.boxplot(data=diabetes_X, y=feature)
    plt.title(f'Boxplot de {feature}')
    plt.ylabel(feature)
plt.tight_layout()
plt.show()

variaveis_quantitativas = list(diabetes_X.columns)

# Análise estatística das variáveis quantitativas
for feature in variaveis_quantitativas:
    print(f"Análise estatística de {feature}:")
    print(f"Média: {diabetes_X[feature].mean()}")
    print(f"Mediana: {diabetes_X[feature].median()}")
    print(f"Desvio Padrão: {diabetes_X[feature].std()}")
    print(f"1º Quartil (Q1): {diabetes_X[feature].quantile(0.25)}")
    print(f"3º Quartil (Q3): {diabetes_X[feature].quantile(0.75)}")
    print("\n")